package com.dev.test.limit;/** * @version 1.0 * @Description * @Author wangbo * @Date 2021/1/6 4:55 下午 */public class Limiter {    /**     * 桶的容量     **/    private long maxToken;    /**     * 令牌生产速度 /s     **/    private long rate;    /**     * 当前令牌数     **/    private long currentToken;    /**     * 上次补充令牌的时间     **/    private long lastAddTime;    // private static Limiter limiter;    public Limiter(long rate) {        this.rate = rate;        this.maxToken = rate;        this.currentToken = rate;        this.lastAddTime = System.currentTimeMillis();    }    public synchronized boolean acquire() {        //每次获取的令牌数        return acquire(1);    }    /**     * 简单的令牌桶算法实现限流算法， 在每次获取token的时候补充令牌，而不是一个线程定时补充令牌。     *     * @param token     * @return     */    public boolean acquire(int token) {        addToken();        if (token > currentToken) {            return false;        }        this.currentToken -= token;        return true;    }    //补充token    public void addToken() {        long accessTime = System.currentTimeMillis();        long durationMs = accessTime - lastAddTime;        if (durationMs > 1000) {            long newTokenNum = (long) (durationMs * rate * 1.0 / 1000);            if (newTokenNum > 0) {                currentToken = Math.min(currentToken + newTokenNum, maxToken);                this.lastAddTime = accessTime / 1000 * 1000; //取当前时间的整秒            }        }    }}